// Generated by LiveScript 1.4.0
var getBoard, setBoard, saveBoardJson, loadBoardJson, rowPeers, colPeers, peers, getPossible, sum, str2bin, bin2str, intersection, difference, solved, solvedCells, getPossible2, numSolved, assign, solveOnlyOneLeft, solve;
getBoard = function(){
  var cells, board, boardNode, lastColumnTotals, i$, ref$, len$, y, rowNode, rowTotal, j$, ref1$, len1$, x, cellNode, k$, ref2$, len2$, totalNode, row, col, ref3$, possible, cell;
  cells = [];
  board = {};
  boardNode = document.getElementById('CurrentKakuroBoard');
  lastColumnTotals = {};
  for (i$ = 0, len$ = (ref$ = boardNode.getElementsByTagName('tr')).length; i$ < len$; ++i$) {
    y = i$;
    rowNode = ref$[i$];
    rowTotal = void 8;
    for (j$ = 0, len1$ = (ref1$ = rowNode.getElementsByTagName('td')).length; j$ < len1$; ++j$) {
      x = j$;
      cellNode = ref1$[j$];
      switch (cellNode.className) {
      case 'cellTotal':
        for (k$ = 0, len2$ = (ref2$ = cellNode.getElementsByTagName('input')).length; k$ < len2$; ++k$) {
          totalNode = ref2$[k$];
          switch (false) {
          case totalNode.name.indexOf('v') === -1:
            lastColumnTotals[x] = Number(totalNode.value);
            break;
          case totalNode.name.indexOf('h') === -1:
            rowTotal = Number(totalNode.value);
            break;
          default:
            throw new Error("Don't know how to process this board @ " + x + ", " + y);
          }
        }
        break;
      case 'cellNumber':
        // fallthrough
      case 'cellNumberError':
        if (rowTotal === void 8) {
          throw new Error("Unknown row total @ " + x + ", " + y);
        }
        if (lastColumnTotals[x] === void 8) {
          throw new Error("Unknown column total @ " + x + ", " + y);
        }
        row = ((ref2$ = board[[x - 1, y]]) != null ? ref2$.row : void 8) || [];
        col = ((ref3$ = board[[x, y - 1]]) != null ? ref3$.col : void 8) || [];
        row.total = rowTotal;
        col.total = lastColumnTotals[x];
        possible = '123456789';
        if (cellNode.children[0].value) {
          possible = String(cellNode.children[0].value);
        }
        cell = board[[x, y]] = {
          possible: possible,
          row: row,
          col: col,
          node: cellNode.children[0]
        };
        row.push(cell);
        col.push(cell);
      }
    }
  }
  return board;
};
setBoard = function(board){
  var i$, cell, results$ = [];
  for (i$ in board) {
    cell = board[i$];
    results$.push(cell.node.value = cell.possible);
  }
  return results$;
};
saveBoardJson = function(board){
  var board2, coords, cell;
  board2 = {};
  for (coords in board) {
    cell = board[coords];
    board2[coords] = {
      possible: cell.possible
    };
  }
  return JSON.stringify(board2);
};
loadBoardJson = function(board, board2){
  var coords, ref$, cell, results$ = [];
  for (coords in ref$ = JSON.parse(board2)) {
    cell = ref$[coords];
    results$.push(board[coords].possible = cell.possible);
  }
  return results$;
};
rowPeers = function(cell){
  var i$, ref$, len$, c, results$ = [];
  for (i$ = 0, len$ = (ref$ = cell.row).length; i$ < len$; ++i$) {
    c = ref$[i$];
    if (c !== cell) {
      results$.push(c);
    }
  }
  return results$;
};
colPeers = function(cell){
  var i$, ref$, len$, c, results$ = [];
  for (i$ = 0, len$ = (ref$ = cell.col).length; i$ < len$; ++i$) {
    c = ref$[i$];
    if (c !== cell) {
      results$.push(c);
    }
  }
  return results$;
};
peers = function(cell){
  return rowPeers(cell).concat(colPeers(cell));
};
getPossible = function(total, length, left){
  var possible, i$, len$, i, rest, j$, len1$, x;
  left == null && (left = '123456789');
  switch (length) {
  case 0:
    return '';
  case 1:
    if (left.split('').join('.').indexOf(total) === -1) {
      return '';
    }
    return String(total);
  }
  if (left.length === 0) {
    return '';
  }
  possible = new Set();
  for (i$ = 0, len$ = left.length; i$ < len$; ++i$) {
    i = left[i$];
    if (possible.has(i)) {
      continue;
    }
    rest = getPossible(total - i, length - 1, left.replace(i, ''));
    if (rest === '') {
      continue;
    }
    possible.add(i);
    for (j$ = 0, len1$ = rest.length; j$ < len1$; ++j$) {
      x = rest[j$];
      possible.add(x);
    }
  }
  return Array.from(possible).join('');
};
console.assert(getPossible(17, 2) === '89');
console.assert(getPossible(16, 2) === '79');
console.assert(getPossible(10, 4) === '1234');
console.assert(getPossible(7, 3) === '124');
console.assert(getPossible(7, 3) === '124');
sum = function(it){
  return it.reduce(function(a, b){
    return a + b;
  }, 0);
};
str2bin = function(str){
  var i;
  return sum(
  (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = str).length; i$ < len$; ++i$) {
      i = ref$[i$];
      results$.push(1 << Number(i) - 1);
    }
    return results$;
  }()));
};
bin2str = function(binary){
  var index;
  return (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = [1, 2, 3, 4, 5, 6, 7, 8, 9]).length; i$ < len$; ++i$) {
      index = ref$[i$];
      if ((binary & 1 << index - 1) !== 0) {
        results$.push(index);
      }
    }
    return results$;
  }()).join('');
};
intersection = function(possible1, possible2){
  return bin2str(str2bin(possible1) & str2bin(possible2));
};
console.assert(intersection('123', '345') === '3');
console.assert(intersection('1234', '345') === '34');
difference = function(possible1, possible2){
  var binary2;
  binary2 = str2bin(possible2);
  return bin2str((str2bin(possible1) | binary2) - binary2);
};
console.assert(difference('123', '345') === '12');
console.assert(difference('1234', '345') === '12');
solved = function(cell){
  if (cell.possible.length === 0) {
    throw new Error("unsolvable board!");
  }
  return cell.possible.length === 1;
};
solvedCells = function(it){
  return it.filter(solved);
};
getPossible2 = function(rowcol){
  var solvedNums, numsLeft;
  solvedNums = solvedCells(rowcol).map(function(c){
    return Number(c.possible[0]);
  });
  numsLeft = difference('123456789', solvedNums.join(''));
  return getPossible(rowcol.total - sum(solvedNums), rowcol.length - solvedNums.length, numsLeft);
};
numSolved = function(board){
  var cell;
  return (function(){
    var i$, ref$, results$ = [];
    for (i$ in ref$ = board) {
      cell = ref$[i$];
      if (solved(cell)) {
        results$.push(cell);
      }
    }
    return results$;
  }()).length;
};
assign = function(cell){
  var i$, ref$, len$, c, results$ = [];
  if (Number(cell.possible) < 1 || Number(cell.possible) > 9) {
    throw new Error("unsolvable board!");
  }
  if (solvedCells(cell.row).length === cell.row.length) {
    if (sum(cell.row.map(function(c){
      return Number(c.possible[0]);
    })) !== cell.row.total) {
      throw new Error("unsolvable board!");
    }
  }
  if (solvedCells(cell.col).length === cell.col.length) {
    if (sum(cell.col.map(function(c){
      return Number(c.possible[0]);
    })) !== cell.col.total) {
      throw new Error("unsolvable board!");
    }
  }
  for (i$ = 0, len$ = (ref$ = peers(cell)).length; i$ < len$; ++i$) {
    c = ref$[i$];
    if (solved(c)) {
      continue;
    }
    c.possible = c.possible.replace(cell.possible, '');
    if (solved(c)) {
      results$.push(assign(c));
    }
  }
  return results$;
};
solveOnlyOneLeft = function(rowcol){
  var unknowns, knownSum, i$, len$, c;
  unknowns = [];
  knownSum = 0;
  for (i$ = 0, len$ = rowcol.length; i$ < len$; ++i$) {
    c = rowcol[i$];
    if (!solved(c)) {
      unknowns.push(c);
    } else {
      knownSum += Number(c.possible[0]);
    }
  }
  if (unknowns.length === 1) {
    unknowns[0].possible = String(rowcol.total - knownSum);
    return assign(unknowns[0]);
  }
};
solve = function(board){
  var _numSolved, i$, cell, rowPossible, colPossible, possible, impossible, possibleCopy, j$, len$, possibility, foundImpossible, newRowPossible, k$, ref$, len1$, rowPeer, newColPossible, colPeer, unknowns, knownSum, coords, boardJson, error;
  do {
    _numSolved = numSolved(board);
    for (i$ in board) {
      cell = board[i$];
      if (solved(cell)) {
        assign(cell);
      }
    }
    for (i$ in board) {
      cell = board[i$];
      if (solved(cell)) {
        continue;
      }
      rowPossible = getPossible2(cell.row);
      colPossible = getPossible2(cell.col);
      possible = intersection(rowPossible, colPossible);
      cell.possible = intersection(cell.possible, possible);
      if (solved(cell)) {
        assign(cell);
      }
      impossible = '';
      possibleCopy = cell.possible;
      for (j$ = 0, len$ = possibleCopy.length; j$ < len$; ++j$) {
        possibility = possibleCopy[j$];
        cell.possible = possibility;
        foundImpossible = false;
        newRowPossible = getPossible2(cell.row);
        for (k$ = 0, len1$ = (ref$ = rowPeers(cell)).length; k$ < len1$; ++k$) {
          rowPeer = ref$[k$];
          if (!solved(rowPeer)) {
            if (intersection(rowPeer.possible, newRowPossible) === '') {
              impossible += possibility;
              foundImpossible = true;
              break;
            }
          }
        }
        if (foundImpossible) {
          continue;
        }
        newColPossible = getPossible2(cell.col);
        for (k$ = 0, len1$ = (ref$ = colPeers(cell)).length; k$ < len1$; ++k$) {
          colPeer = ref$[k$];
          if (!solved(colPeer)) {
            if (intersection(colPeer.possible, newColPossible) === '') {
              impossible += possibility;
              break;
            }
          }
        }
      }
      cell.possible = difference(possibleCopy, impossible);
      if (solved(cell)) {
        assign(cell);
      }
    }
    for (i$ in board) {
      cell = board[i$];
      unknowns = [];
      knownSum = 0;
      solveOnlyOneLeft(cell.row);
      solveOnlyOneLeft(cell.col);
    }
  } while (numSolved(board) !== _numSolved);
  for (coords in board) {
    cell = board[coords];
    if (solved(cell)) {
      continue;
    }
    boardJson = saveBoardJson(board);
    possibleCopy = cell.possible;
    for (i$ = 0, len$ = possibleCopy.length; i$ < len$; ++i$) {
      possible = possibleCopy[i$];
      try {
        cell.possible = possible;
        assign(cell);
        solve(board);
        while (Object.keys(board).length !== numSolved(board)) {
          solve(board);
        }
        break;
      } catch (e$) {
        error = e$;
        loadBoardJson(board, boardJson);
      }
    }
    break;
  }
  setBoard(board);
};
solve(getBoard());